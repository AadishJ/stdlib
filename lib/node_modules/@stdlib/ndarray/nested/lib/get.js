/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable max-len */

'use strict';

// MODULES //

var isFunction = require( '@stdlib/assert/is-function' );
var trim = require( '@stdlib/string/base/trim' );
var MultiSlice = require( '@stdlib/slice/multi' );
var seq2slice = require( '@stdlib/slice/base/seq2slice' );
var str2slice = require( '@stdlib/slice/base/str2slice' );
var str2multislice = require( '@stdlib/slice/base/str2multislice' );
var normalizeMultiSlice = require( '@stdlib/slice/base/normalize-multi-slice' );
var format = require( '@stdlib/string/format' );
var hasProperty = require( './has_property.js' );
var RE_INTEGER = require( './re_integer.js' );
var sliceView = require( './view.js' );
var empty = require( './empty.js' );


// FUNCTIONS //

/**
* Returns a shape representing an empty array having a first dimension equal to zero.
*
* @private
* @param {NonNegativeIntegerArray} shape - input shape
* @returns {NonNegativeIntegerArray} output shape having the first dimension equal to zero
*/
function emptyShape( shape ) {
	var out;
	var N;
	var i;

	N = shape.length;
	if ( N === 0 ) {
		return [];
	}
	out = [ 0 ];
	for ( i = 1; i < N; i++ ) {
		out.push( shape[ i ] );
	}
	return out;
}

/**
* Expands a single slice to a multi-slice to match the dimensionality of a provided shape.
*
* @private
* @param {Slice} slice - input slice
* @param {NonNegativeIntegerArray} shape - input shape
* @returns {MultiSlice} multi-slice
*/
function expandSlice( slice, shape ) {
	var args;
	var i;

	args = [ slice ];
	for ( i = 1; i < shape.length; i++ ) {
		args.push( null );
	}
	return MultiSlice.apply( null, args );
}


// MAIN //

/**
* Trap for retrieving property values.
*
* @private
* @param {Object} target - target object
* @param {(string|symbol)} property - property name
* @param {Object} receiver - the proxy object or an object inheriting from the proxy
* @throws {Error} invalid slice operation
* @throws {RangeError} slice exceeds array bounds
* @throws {Error} slice increment must be a non-zero integer
* @returns {*} result
*/
function get( target, property, receiver ) {
	var strides;
	var offset;
	var strict;
	var dtype;
	var shape;
	var order;
	var value;
	var parts;
	var prop;
	var ch;
	var ns;
	var s;
	if ( hasProperty( property ) ) {
		value = target[ property ];
		if ( isFunction( value ) ) {
			return wrapper;
		}
		return value;
	}
	prop = trim( property );

	// Resolve target meta data:
	dtype = target.dtype;
	shape = target.shape;
	strides = target.strides;
	offset = target.offset;
	order = target.order;
	strict = false; // TODO: support strict mode

	// Retrieve the first character in order to to detect how a slice operation was specified:
	ch = prop[ 0 ];

	// Case: slice
	if ( ch === 'S' ) {
		// Convert the string to a slice object:
		s = str2slice( property );
		if ( s === null ) {
			throw new Error( format( 'invalid operation. Unsupported slice operation. Value: `%s`.', property ) );
		}
		// Convert the slice to a multi-slice object:
		s = expandSlice( s, shape );

		// Normalize the slice object based on the array shape:
		ns = normalizeMultiSlice( s, shape, true );

		// If the slice exceeds array bounds, return an empty one-dimensional array...
		if ( ns.code ) {
			if ( strict ) {
				throw new RangeError( format( 'invalid operation. Slice exceeds array bounds. Array shape: (%s).', shape.join( ',' ) ) );
			}
			return empty( receiver.constructor, dtype, emptyShape( shape ), order );
		}
		// Return a view of the provided array:
		return sliceView( receiver.constructor, dtype, target.data, shape, strides, offset, order, s, ns );
	}

	// Case: multi-slice (e.g., 'MultiSlice(1)', 'MultiSlice(Slice(0,10,2)')
	if ( ch === 'M' ) {
		// Convert the string to a slice object:
		s = str2multislice( prop );
		if ( s === null ) {
			throw new Error( format( 'invalid operation. Unsupported slice operation. Value: `%s`.', property ) );
		}
		// Ensure that we were provided a one-dimensional multi-slice:
		if ( s.ndims !== 1 ) {
			throw new RangeError( format( 'invalid operation. The number of slice dimensions must equal one. Slice dimensions: %u.', s.ndims ) );
		}
		// Expand the multi-slice:
		s = expandSlice( s.data[ 0 ], shape );

		// Normalize the slice object based on the array shape:
		ns = normalizeMultiSlice( s, shape, true );

		// If the slice exceeds array bounds, return an empty one-dimensional array...
		if ( ns.code ) {
			if ( strict ) {
				throw new RangeError( format( 'invalid operation. Slice exceeds array bounds. Array shape: (%s).', shape.join( ',' ) ) );
			}
			return empty( receiver.constructor, dtype, emptyShape( shape ), order );
		}
		// Return a view of the provided array:
		return sliceView( receiver.constructor, dtype, target.data, shape, strides, offset, order, s, ns );
	}

	// Case: integer
	if ( RE_INTEGER.test( prop ) ) {
		// Convert the string to a numeric value:
		s = parseInt( prop, 10 );

		// Convert to a multi-slice object:
		s = expandSlice( s, shape );

		// Normalize the slice object based on the array shape:
		ns = normalizeMultiSlice( s, shape, true );

		// If the slice exceeds array bounds, return an empty one-dimensional array...
		if ( ns.code ) {
			if ( strict ) {
				throw new RangeError( format( 'invalid operation. Slice exceeds array bounds. Array shape: (%s).', shape.join( ',' ) ) );
			}
			return empty( receiver.constructor, dtype, emptyShape( shape ), order );
		}
		// Return a view of the provided array:
		return sliceView( receiver.constructor, dtype, target.data, shape, strides, offset, order, s, ns );
	}
	// Check whether we were provided a subsequence string...
	parts = prop.split( /\s*,\s*/ );
	if ( parts.length > 1 ) {
		throw new RangeError( format( 'invalid operation. The number of slice dimensions must equal one. Slice dimensions: %u.', parts.length ) );
	}
	prop = parts[ 0 ];
	if ( prop.length === 0 ) {
		throw new RangeError( format( 'invalid operation. The number of slice dimensions must equal one. Slice dimensions: %u.', 0 ) );
	}
	// Attempt to convert the subsequence string to a slice object:
	s = seq2slice( prop, shape[ 0 ], true );
	if ( s.code ) {
		if ( s.code === 'ERR_SLICE_OUT_OF_BOUNDS' ) {
			if ( strict ) {
				throw new RangeError( format( 'invalid operation. Slice exceeds array bounds. Array shape: (%s).', shape.join( ',' ) ) );
			}
			// Return an empty zero-dimensional array:
			return empty( receiver.constructor, dtype, emptyShape( shape ), order );
		}
		if ( s.code === 'ERR_SLICE_INVALID_INCREMENT' ) {
			throw new Error( format( 'invalid operation. A subsequence increment must be a non-zero integer. Value: `%s`.', property ) );
		}
		if ( s.code === 'ERR_SLICE_INVALID_SUBSEQUENCE' ) {
			throw new Error( format( 'invalid operation. Unsupported slice operation. Value: `%s`.', property ) );
		}
	}
	// Convert to a multi-slice object:
	s = expandSlice( s, shape );

	// Normalize the slice object based on the array shape:
	ns = normalizeMultiSlice( s, shape, true );

	// Return a view of the provided array:
	return sliceView( receiver.constructor, dtype, target.data, shape, strides, offset, order, s, ns );

	/**
	* Method wrapper.
	*
	* @private
	* @returns {*} results
	*/
	function wrapper() {
		var args;
		var i;

		args = [];
		for ( i = 0; i < arguments.length; i++ ) {
			args.push( arguments[ i ] );
		}
		return value.apply( ( this === receiver ) ? target : this, args ); // eslint-disable-line no-invalid-this
	}
}


// EXPORTS //

module.exports = get;
