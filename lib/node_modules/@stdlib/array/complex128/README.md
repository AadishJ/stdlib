<!--

@license Apache-2.0

Copyright (c) 2024 The Stdlib Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

-->

# Complex128Array

> 128-bit complex number array.

<!-- Section to include introductory text. Make sure to keep an empty line after the intro `section` element and another before the `/section` close. -->

<section class="intro">

</section>

<!-- /.intro -->

<!-- Package usage documentation. -->

<section class="usage">

## Usage

```javascript
const Complex128Array = require( '@stdlib/array/complex128' );
```

<a name="constructor"></a>

#### Complex128Array()

Creates a 128-bit complex number array.

```javascript
const arr = new Complex128Array();
// returns <Complex128Array>
```

#### Complex128Array( length )

Creates a 128-bit complex number array having a specified `length`.

```javascript
const arr = new Complex128Array( 10 );
// returns <Complex128Array>

const len = arr.length;
// returns 10
```

#### Complex128Array( complexarray )

Creates a 128-bit complex number array from another complex number array.

```javascript
const arr1 = new Complex128Array( [ 1.0, -1.0, 2.0, -2.0 ] ); // [ re, im, re, im ]
// returns <Complex128Array>

const arr2 = new Complex128Array( arr1 );
// returns <Complex128Array>

const len = arr2.length;
// returns 2
```

#### Complex128Array( typedarray )

Creates a 128-bit complex number array from a [typed array][@stdlib/array/typed] containing interleaved real and imaginary components.

```javascript
const Float64Array = require( '@stdlib/array/float64' );

const buf = new Float64Array( [ 1.0, -1.0, 2.0, -2.0 ] ); // [ re, im, re, im ]
// returns <Float64Array>[ 1.0, -1.0, 2.0, -2.0 ]

const arr = new Complex128Array( buf );
// returns <Complex128Array>

const len = arr.length;
// returns 2
```

#### Complex128Array( obj )

Creates a 128-bit complex number array from an array-like object or iterable.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

// From an array of interleaved real and imaginary components:
const arr1 = new Complex128Array( [ 1.0, -1.0, 2.0, -2.0 ] );
// returns <Complex128Array>

let len = arr1.length;
// returns 2

// From an array containing complex numbers:
const buf = [ new Complex128( 1.0, -1.0 ), new Complex128( 2.0, -2.0 ) ];
const arr2 = new Complex128Array( buf );

len = arr2.length;
// returns 2
```

#### Complex128Array( buffer\[, byteOffset\[, length]] )

Returns a 128-bit complex number array view of an [`ArrayBuffer`][@stdlib/array/buffer].

```javascript
const ArrayBuffer = require( '@stdlib/array/buffer' );
const buf = new ArrayBuffer( 480 );

const arr1 = new Complex128Array( buf );
// returns <Complex128Array>

let len = arr1.length;
// returns 30

const arr2 = new Complex128Array( buf, 16 );
// returns <Complex128Array>

len = arr2.length;
// returns 29

const arr3 = new Complex128Array( buf, 16, 20 );
// returns <Complex128Array>

len = arr3.length;
// returns 20
```

* * *

### Properties

<a name="static-prop-bytes-per-element"></a>

#### Complex128Array.BYTES_PER_ELEMENT

Static property returning the size (in bytes) of each array element.

```javascript
const nbytes = Complex128Array.BYTES_PER_ELEMENT;
// returns 16
```

<a name="static-prop-name"></a>

#### Complex128Array.name

Static property returning the constructor name.

```javascript
const str = Complex128Array.name;
// returns 'Complex128Array'
```

<a name="prop-buffer"></a>

#### Complex128Array.prototype.buffer

Pointer to the underlying data buffer.

```javascript
const arr = new Complex128Array( 2 );
// returns <Complex128Array>

const buf = arr.buffer;
// returns <ArrayBuffer>
```

<a name="prop-byte-length"></a>

#### Complex128Array.prototype.byteLength

Size (in bytes) of the array.

```javascript
const arr = new Complex128Array( 10 );
// returns <Complex128Array>

const nbytes = arr.byteLength;
// returns 160
```

<a name="prop-byte-offset"></a>

#### Complex128Array.prototype.byteOffset

Offset (in bytes) of the array from the start of its underlying `ArrayBuffer`.

```javascript
const ArrayBuffer = require( '@stdlib/array/buffer' );

let arr = new Complex128Array( 10 );
// returns <Complex128Array>

let offset = arr.byteOffset;
// returns 0

const buf = new ArrayBuffer( 480 );
arr = new Complex128Array( buf, 128 );
// returns <Complex128Array>

offset = arr.byteOffset;
// returns 128
```

<a name="prop-bytes-per-element"></a>

#### Complex128Array.prototype.BYTES_PER_ELEMENT

Size (in bytes) of each array element.

```javascript
const arr = new Complex128Array( 10 );
// returns <Complex128Array>

const nbytes = arr.BYTES_PER_ELEMENT;
// returns 16
```

<a name="prop-length"></a>

#### Complex128Array.prototype.length

Number of array elements.

```javascript
const arr = new Complex128Array( 10 );
// returns <Complex128Array>

const len = arr.length;
// returns 10
```

* * *

### Methods

<a name="static-method-from"></a>

#### Complex128Array.from( src\[, clbk\[, thisArg]] )

Creates a new 128-bit complex number array from an array-like object or an iterable.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

// Create an array from interleaved real and imaginary components:
let arr = Complex128Array.from( [ 1.0, -1.0 ] );
// returns <Complex128Array>

let len = arr.length;
// returns 1

// Create an array from an array of complex numbers:
arr = Complex128Array.from( [ new Complex128( 1.0, -1.0 ) ] );
// returns <Complex128Array>

len = arr.length;
// returns 1
```

The iterator returned by an iterable must return either a complex number or an array-like object containing a real and imaginary component.

```javascript
const ITERATOR_SYMBOL = require( '@stdlib/symbol/iterator' );
const Float64Array = require( '@stdlib/array/float64' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

let iter;
let arr;
let len;
let re;
let im;
let z;

// Define a function which returns an iterator protocol-compliant object...
function iterable() {
    const buf = new Float64Array( 2 );
    let i = 0;
    return {
        'next': next
    };

    function next() {
        i += 1;
        if ( i < 3 ) {
            // Reuse allocated memory...
            buf[ 0 ] = i;
            buf[ 1 ] = -i;
            return {
                'value': buf
            };
        }
        return {
            'done': true
        };
    }
}

if ( ITERATOR_SYMBOL === null ) {
    console.error( 'Environment does not support iterables.' );
} else {
    // Create an iterable:
    iter = {};
    iter[ ITERATOR_SYMBOL ] = iterable;

    // Generate a complex number array:
    arr = Complex128Array.from( iter );
    // returns <Complex128Array>

    len = arr.length;
    // returns 2

    z = arr.get( 0 );
    // returns <Complex128>

    re = real( z );
    // returns 1.0

    im = imag( z );
    // returns -1.0
}
```

To invoke a function for each `src` value, provide a callback function. If `src` is an iterable or an array-like object containing complex numbers, the callback must return either a complex number

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function map( z ) {
    return new Complex128( real(z)*2.0, imag(z)*2.0 );
}

// Create a source array:
const src = [ new Complex128( 1.0, -1.0 ) ];

// Create a new complex number array by scaling the source array:
const arr = Complex128Array.from( src, map );
// returns <Complex128Array>

const len = arr.length;
// returns 1

const z = arr.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns -2.0
```

or an array-like object containing real and imaginary components

```javascript
const Float64Array = require( '@stdlib/array/float64' );
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

// Return a callback which reuses allocated memory...
function mapFcn() {
    const buf = new Float64Array( 2 );
    return map;

    function map( z ) {
        buf[ 0 ] = real( z ) * 2.0;
        buf[ 1 ] = imag( z ) * 2.0;
        return buf;
    }
}

// Create a source array:
const src = [ new Complex128( 1.0, -1.0 ), new Complex128( 2.0, -2.0 ) ];

// Create a new complex number array by scaling the source array:
const arr = Complex128Array.from( src, mapFcn() );
// returns <Complex128Array>

const len = arr.length;
// returns 2

let z = arr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 2.0

let im = imag( z );
// returns -2.0

z = arr.get( 1 );
// returns <Complex128>

re = real( z );
// returns 4.0

im = imag( z );
// returns -4.0
```

If `src` is an array-like object containing interleaved real and imaginary components, the callback is invoked for each component and should return the transformed component value.

```javascript
const Float64Array = require( '@stdlib/array/float64' );
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function map( v ) {
    return v * 2.0;
}

// Create a source array:
const src = new Float64Array( [ 1.0, -1.0 ] );

// Create a new complex number array by scaling the source array:
const arr = Complex128Array.from( src, map );
// returns <Complex128Array>

const len = arr.length;
// returns 1

const z = arr.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns -2.0
```

A callback function is provided two arguments:

-   **value**: source value.
-   **index**: source index.

To set the callback execution context, provide a `thisArg`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function map( z ) {
    this.count += 1;
    return new Complex128( real(z)*2.0, imag(z)*2.0 );
}

// Create a source array:
const src = [ new Complex128( 1.0, -1.0 ), new Complex128( 1.0, -1.0 ) ];

// Define an execution context:
const ctx = {
    'count': 0
};

// Create a new complex number array by scaling the source array:
const arr = Complex128Array.from( src, map, ctx );
// returns <Complex128Array>

const len = arr.length;
// returns 2

const n = ctx.count;
// returns 2
```

<a name="static-method-of"></a>

#### Complex128Array.of( element0\[, element1\[, ...elementN]] )

Creates a new 128-bit complex number array from a variable number of arguments.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

let arr = Complex128Array.of( 1.0, -1.0, 2.0, -2.0 );
// returns <Complex128Array>

let len = arr.length;
// returns 2

const z1 = new Complex128( 1.0, -1.0 );
const z2 = new Complex128( 2.0, -2.0 );

arr = Complex128Array.of( z1, z2 );
// returns <Complex128Array>

len = arr.length;
// returns 2
```

<a name="method-at"></a>

#### Complex128Array.prototype.at( i )

Returns an array element located at integer position (index) `i`, with support for both nonnegative and negative integer positions.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Set the first, second, and last elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 9.0, -9.0 ], 9 );

// Get the first element:
let z = arr.at( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns -1.0

// Get the last element:
z = arr.at( -1 );
// returns <Complex128>

re = real( z );
// returns 9.0

im = imag( z );
// returns -9.0
```

If provided an out-of-bounds index, the method returns `undefined`.

```javascript
const arr = new Complex128Array( 10 );

let z = arr.at( 100 );
// returns undefined

z = arr.at( -100 );
// returns undefined
```

<a name="method-copy-within"></a>

#### Complex128Array.prototype.copyWithin( target, start\[, end] )

Copies a sequence of elements within the array starting at `start` and ending at `end` (non-inclusive) to the position starting at `target`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 4 );

// Set the array elements:
arr.set( new Complex128( 1.0, -1.0 ), 0 );
arr.set( new Complex128( 2.0, -2.0 ), 1 );
arr.set( new Complex128( 3.0, -3.0 ), 2 );
arr.set( new Complex128( 4.0, -4.0 ), 3 );

// Get the first array element:
let z = arr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns -1.0

// Get the second array element:
z = arr.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns -2.0

// Copy the last two elements to the first two elements:
arr.copyWithin( 0, 2 );

// Get the first array element:
z = arr.get( 0 );
// returns <Complex128>

re = real( z );
// returns 3.0

im = imag( z );
// returns -3.0

// Get the second array element:
z = arr.get( 1 );
// returns <Complex128>

re = real( z );
// returns 4.0

im = imag( z );
// returns -4.0
```

By default, `end` equals the number of array elements (i.e., one more than the last array index). To limit the sequence length, provide an `end` argument.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 4 );

// Set the array elements:
arr.set( new Complex128( 1.0, -1.0 ), 0 );
arr.set( new Complex128( 2.0, -2.0 ), 1 );
arr.set( new Complex128( 3.0, -3.0 ), 2 );
arr.set( new Complex128( 4.0, -4.0 ), 3 );

// Get the third array element:
let z = arr.get( 2 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns -3.0

// Get the last array element:
z = arr.get( 3 );
// returns <Complex128>

re = real( z );
// returns 4.0

im = imag( z );
// returns -4.0

// Copy the first two elements to the last two elements:
arr.copyWithin( 2, 0, 2 );

// Get the third array element:
z = arr.get( 2 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns -1.0

// Get the last array element:
z = arr.get( 3 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns -2.0
```

When a `target`, `start`, and/or `end` index is negative, the respective index is determined relative to the last array element. The following example achieves the same behavior as the previous example:

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 4 );

// Set the array elements:
arr.set( new Complex128( 1.0, -1.0 ), 0 );
arr.set( new Complex128( 2.0, -2.0 ), 1 );
arr.set( new Complex128( 3.0, -3.0 ), 2 );
arr.set( new Complex128( 4.0, -4.0 ), 3 );

// Get the third array element:
let z = arr.get( 2 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns -3.0

// Get the last array element:
z = arr.get( 3 );
// returns <Complex128>

re = real( z );
// returns 4.0

im = imag( z );
// returns -4.0

// Copy the first two elements to the last two elements using negative indices:
arr.copyWithin( -2, -4, -2 );

// Get the third array element:
z = arr.get( 2 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns -1.0

// Get the last array element:
z = arr.get( 3 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns -2.0
```

<a name="method-entries"></a>

#### Complex128Array.prototype.entries()

Returns an iterator for iterating over array key-value pairs.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

let arr = [
    new Complex128( 1.0, -1.0 ),
    new Complex128( 2.0, -2.0 ),
    new Complex128( 3.0, -3.0 )
];
arr = new Complex128Array( arr );

// Create an iterator:
const it = arr.entries();

// Iterate over the key-value pairs...
let v = it.next().value;
// returns [ 0, <Complex128> ]

let re = real( v[ 1 ] );
// returns 1.0

let im = imag( v[ 1 ] );
// returns -1.0

v = it.next().value;
// returns [ 1, <Complex128> ]

re = real( v[ 1 ] );
// returns 2.0

im = imag( v[ 1 ] );
// returns -2.0

v = it.next().value;
// returns [ 2, <Complex128> ]

re = real( v[ 1 ] );
// returns 3.0

im = imag( v[ 1 ] );
// returns -3.0

const bool = it.next().done;
// returns true
```

<a name="method-every"></a>

#### Complex128Array.prototype.every( predicate\[, thisArg] )

Returns a boolean indicating whether all elements pass a test.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

// Check whether all elements pass a test:
const bool = arr.every( predicate );
// returns true
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const bool = arr.every( predicate, context );
// returns true

const count = context.count;
// returns 3
```

<a name="method-fill"></a>

#### Complex128Array.prototype.fill( value\[, start\[, end]] )

Returns a modified typed array filled with a fill value.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 3 );

// Set all elements to the same value:
arr.fill( new Complex128( 1.0, 1.0 ) );

let z = arr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns 1.0

z = arr.get( 2 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns 1.0

// Fill all elements starting from the second element:
arr.fill( new Complex128( 2.0, 2.0 ), 1 );

z = arr.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns 2.0

z = arr.get( 2 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns 2.0

// Fill all elements from first element until the second-to-last element:
arr.fill( new Complex128( 3.0, 3.0 ), 0, 2 );

z = arr.get( 0 );
// returns <Complex128>

re = real( z );
// returns 3.0

im = imag( z );
// returns 3.0

z = arr.get( 1 );
// returns <Complex128>

re = real( z );
// returns 3.0

im = imag( z );
// returns 3.0
```

When a `start` and/or `end` index is negative, the respective index is determined relative to the last array element.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 3 );

// Set all array elements, except the last element, to the same value:
arr.fill( new Complex128( 1.0, 1.0 ), 0, -1 );

let z = arr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns 1.0

z = arr.get( arr.length - 1 );
// returns <Complex128>

re = real( z );
// returns 0.0

im = imag( z );
// returns 0.0
```

<a name="method-filter"></a>

#### Complex128Array.prototype.filter( predicate\[, thisArg] )

Returns a new array containing the elements of an array which pass a test implemented by a predicate function.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const out = arr.filter( predicate );
// returns <Complex128Array>

const len = out.length;
// returns 1

const z = out.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns 2.0
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 && real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const out = arr.filter( predicate, context );
// returns <Complex128Array>

const len = out.length;
// returns 2

const count = context.count;
// returns 3
```

<a name="method-find"></a>

#### Complex128Array.prototype.find( predicate\[, thisArg] )

Returns the first element in an array for which a predicate function returns a truthy value.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.find( predicate );
// returns <Complex128>

const re = real( z );
// returns 1.0

const im = imag( z );
// returns 1.0
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 && real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.find( predicate, context );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns 2.0

const count = context.count;
// returns 2
```

<a name="method-find-index"></a>

#### Complex128Array.prototype.findIndex( predicate\[, thisArg] )

Returns the index of the first element in an array for which a predicate function returns a truthy value.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const idx = arr.findIndex( predicate );
// returns 2
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 && real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const idx = arr.findIndex( predicate, context );
// returns -1

const count = context.count;
// returns 3
```

<a name="method-find-last"></a>

#### Complex128Array.prototype.findLast( predicate\[, thisArg] )

Returns the last element in an array for which a predicate function returns a truthy value.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.findLast( predicate );
// returns <Complex128>

const re = real( z );
// returns 3.0

const im = imag( z );
// returns 3.0
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 && real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const z = arr.findLast( predicate, context );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns 2.0

const count = context.count;
// returns 2
```

<a name="method-find-last-index"></a>

#### Complex128Array.prototype.findLastIndex( predicate\[, thisArg] )

Returns the index of the last element in an array for which a predicate function returns a truthy value.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const idx = arr.findLastIndex( predicate );
// returns 1
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( i >= 0 && real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const idx = arr.findLastIndex( predicate, context );
// returns -1

const count = context.count;
// returns 3
```

<a name="method-for-each"></a>

#### Complex128Array.prototype.forEach( callbackFn\[, thisArg] )

Invokes a function once for each array element.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

function log( v, i ) {
    console.log( '%s: %s', i, v.toString() );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

arr.forEach( log );
/* =>
    0: 1 + 1i
    1: 2 + 2i
    2: 3 + 3i
*/
```

The invoked function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

function fcn( v, i ) {
    this.count += 1;
    console.log( '%s: %s', i, v.toString() );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

arr.forEach( fcn, context );
/* =>
    0: 1 + 1i
    1: 2 + 2i
    2: 3 + 3i
*/

const count = context.count;
// returns 3
```

<a name="method-get"></a>

#### Complex128Array.prototype.get( i )

Returns an array element located at position (index) `i`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Set the first element:
arr.set( [ 1.0, -1.0 ], 0 );

// Get the first element:
const z = arr.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 1.0

const im = imag( z );
// returns -1.0
```

If provided an out-of-bounds index, the method returns `undefined`.

```javascript
const arr = new Complex128Array( 10 );

const z = arr.get( 100 );
// returns undefined
```

<a name="method-includes"></a>

#### Complex128Array.prototype.includes( searchElement\[, fromIndex] )

Returns a boolean indicating whether an array includes a provided value.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 5 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );
arr.set( [ 4.0, -4.0 ], 3 );
arr.set( [ 5.0, -5.0 ], 4 );

let bool = arr.includes( new Complex128( 3.0, -3.0 ) );
// returns true

bool = arr.includes( new Complex128( 3.0, -3.0 ), 3 );
// returns false

bool = arr.includes( new Complex128( 4.0, -4.0 ), -3 );
// returns true
```

<a name="method-index-of"></a>

#### Complex128Array.prototype.indexOf( searchElement\[, fromIndex] )

Returns the first index at which a given element can be found.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 5 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );
arr.set( [ 4.0, -4.0 ], 3 );
arr.set( [ 2.0, -2.0 ], 4 );

let idx = arr.indexOf( new Complex128( 3.0, -3.0 ) );
// returns 2

idx = arr.indexOf( new Complex128( 2.0, -2.0 ), 2 );
// returns 4

idx = arr.indexOf( new Complex128( 4.0, -4.0 ), -3 );
// returns 3
```

If `searchElement` is not present in the array, the method returns `-1`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 5 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );

let idx = arr.indexOf( new Complex128( 3.0, -3.0 ) );
// returns -1

idx = arr.indexOf( new Complex128( 1.0, -1.0 ), 1 );
// returns -1
```

<a name="method-join"></a>

#### Complex128Array.prototype.join( \[separator] )

Returns a new string by concatenating all array elements.

```javascript
const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const str = arr.join();
// returns '1 + 1i,2 - 2i,3 + 3i'
```

By default, the method separates serialized array elements with a comma. To use an alternative separator, provide a `separator` string.

```javascript
const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const str = arr.join( '/' );
// returns '1 + 1i/2 - 2i/3 + 3i'
```

<a name="method-keys"></a>

#### Complex128Array.prototype.keys()

Returns an iterator for iterating over each index key in a typed array.

```javascript
const arr = new Complex128Array( 2 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );

const iter = arr.keys();

let v = iter.next().value;
// returns 0

v = iter.next().value;
// returns 1

const bool = iter.next().done;
// returns true
```

The returned [iterator][mdn-iterator-protocol] protocol-compliant object has the following properties:

-   **next**: function which returns an [iterator][mdn-iterator-protocol] protocol-compliant object containing the next iterated value (if one exists) assigned to a `value` property and a `done` property having a `boolean` value indicating whether the [iterator][mdn-iterator-protocol] is finished.
-   **return**: function which closes an [iterator][mdn-iterator-protocol] and returns a single (optional) argument in an [iterator][mdn-iterator-protocol] protocol-compliant object.

<a name="method-last-index-of"></a>

#### Complex128Array.prototype.lastIndexOf( searchElement\[, fromIndex] )

Returns the last index at which a given element can be found.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 5 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );
arr.set( [ 4.0, -4.0 ], 3 );
arr.set( [ 2.0, -2.0 ], 4 );

let idx = arr.lastIndexOf( new Complex128( 3.0, -3.0 ) );
// returns 2

idx = arr.lastIndexOf( new Complex128( 2.0, -2.0 ), 2 );
// returns 1

idx = arr.lastIndexOf( new Complex128( 4.0, -4.0 ), -1 );
// returns 3
```

If `searchElement` is not present in the array, the method returns `-1`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 5 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );

let idx = arr.lastIndexOf( new Complex128( 3.0, -3.0 ) );
// returns -1

idx = arr.lastIndexOf( new Complex128( 2.0, -2.0 ), 0 );
// returns -1
```

<a name="method-map"></a>

#### Complex128Array.prototype.map( callbackFn\[, thisArg] )

Returns a new array with each element being the result of a provided callback function.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function scale( v ) {
    return new Complex128( 2.0*real( v ), 2.0*imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const out = arr.map( scale );
// returns <Complex128Array>

const z = out.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns -2.0
```

The callback function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function scale( v ) {
    this.count += 1;
    return new Complex128( 2.0*real( v ), 2.0*imag( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const out = arr.map( scale, context );
// returns <Complex128Array>

const count = context.count;
// returns 3
```

<a name="method-reduce"></a>

#### Complex128Array.prototype.reduce( reducerFn\[, initialValue] )

Applies a provided callback function to each element of the array, in order, passing in the return value from the calculation on the preceding element and returning the accumulated result upon completion.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );
const cadd = require( '@stdlib/complex/float64/base/add' );

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.reduce( cadd );
// returns <Complex128>

const re = real( z );
// returns 6.0

const im = imag( z );
// returns 6.0
```

The reducer function is provided four arguments:

-   **acc**: accumulated result.
-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

By default, the function initializes the accumulated result to the first element in the array and passes the second array element as `value` during the first invocation of the provided callback. To begin accumulation from a different starting value and pass in the first array element as `value` during the first invocation of the provided callback, provide an `initialValue` argument.

```javascript
const real = require( '@stdlib/complex/float64/real' );

function reducer( acc, v ) {
    acc += real( v );
    return acc;
}

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.reduce( reducer, 0.0 );
// returns 6.0
```

<a name="method-reduce-right"></a>

#### Complex128Array.prototype.reduceRight( reducerFn\[, initialValue] )

Applies a provided callback function to each element of the array, in reverse order, passing in the return value from the calculation on the following element and returning the accumulated result upon completion.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );
const cadd = require( '@stdlib/complex/float64/base/add' );

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.reduceRight( cadd );
// returns <Complex128>

const re = real( z );
// returns 6.0

const im = imag( z );
// returns 6.0
```

The reducer function is provided four arguments:

-   **acc**: accumulated result.
-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

By default, the function initializes the accumulated result to the last element in the array and passes the second-last array element as `value` during the first invocation of the provided callback. To begin accumulation from a different starting value and pass in the last array element as `value` during the first invocation of the provided callback, provide an `initialValue` argument.

```javascript
const real = require( '@stdlib/complex/float64/real' );

function reducer( acc, v ) {
    acc += real( v );
    return acc;
}

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const z = arr.reduceRight( reducer, 0.0 );
// returns 6.0
```

<a name="method-reverse"></a>

#### Complex128Array.prototype.reverse()

Reverses an array in-place.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const out = arr.reverse();
// returns <Complex128Array>

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns 3.0

z = out.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns 2.0

z = out.get( 2 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns 1.0
```

<a name="method-set"></a>

#### Complex128Array.prototype.set( z\[, i] )

Sets one or more array elements.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Get the first element:
let z = arr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 0.0

let im = imag( z );
// returns 0.0

// Set the first element:
arr.set( new Complex128( 1.0, -1.0 ) );

// Get the first element:
z = arr.get( 0 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns -1.0
```

By default, the method sets array elements starting at position (index) `i = 0`. To set elements starting elsewhere in the array, provide an index argument `i`.

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Get the fifth element:
let z = arr.get( 4 );
// returns <Complex128>

let re = real( z );
// returns 0.0

let im = imag( z );
// returns 0.0

// Set the fifth element:
arr.set( new Complex128( 1.0, -1.0 ), 4 );

// Get the fifth element:
z = arr.get( 4 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns -1.0
```

In addition to providing a complex number, to set one or more array elements, provide an array-like object containing either complex numbers

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Define an array of complex numbers:
const buf = [
    new Complex128( 1.0, -1.0 ),
    new Complex128( 2.0, -2.0 ),
    new Complex128( 3.0, -3.0 )
];

// Set the fifth, sixth, and seventh elements:
arr.set( buf, 4 );

// Get the sixth element:
const z = arr.get( 5 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns -2.0
```

or interleaved real and imaginary components

```javascript
const Float64Array = require( '@stdlib/array/float64' );
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 10 );

// Define an interleaved array of real and imaginary components:
const buf = new Float64Array( [ 1.0, -1.0, 2.0, -2.0, 3.0, -3.0 ] );

// Set the fifth, sixth, and seventh elements:
arr.set( buf, 4 );

// Get the sixth element:
const z = arr.get( 5 );
// returns <Complex128>

const re = real( z );
// returns 2.0

const im = imag( z );
// returns -2.0
```

A few notes:

-   If `i` is out-of-bounds, the method throws an error.
-   If a target array cannot accommodate all values (i.e., the length of source array plus `i` exceeds the target array length), the method throws an error.
-   If provided a [typed array][@stdlib/array/typed] which shares an [`ArrayBuffer`][@stdlib/array/buffer] with the target array, the method will intelligently copy the source range to the destination range.

<a name="method-slice"></a>

#### Complex128Array.prototype.slice( \[start\[, end]] )

Copies a portion of a typed array to a new typed array.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const out = arr.slice();
// returns <Complex128Array>

const len = out.length;
// returns 4

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns 2.0

z = out.get( len-1 );
// returns <Complex128>

re = real( z );
// returns 7.0

im = imag( z );
// returns 8.0
```

By default, the method returns a typed array beginning with the first array element. To specify an alternative array index at which to begin, provide a `start` index (inclusive).

```javascript
const imag = require( '@stdlib/complex/float64/imag' );
const real = require( '@stdlib/complex/float64/real' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const out = arr.slice( 1 );
// returns <Complex128Array>

const len = out.length;
// returns 3

const z = out.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 3.0

const im = imag( z );
// returns 4.0
```

By default, the method returns a typed array which includes all array elements after `start`. To limit the number of array elements after `start`, provide an `end` index (exclusive).

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const out = arr.slice( 1, -1 );
// returns <Complex128Array>

const len = out.length;
// returns 2

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns 4.0

z = out.get( len-1 );
// returns <Complex128>

re = real( z );
// returns 5.0

im = imag( z );
// returns 6.0
```

<a name="method-some"></a>

#### Complex128Array.prototype.some( predicate\[, thisArg] )

Returns a boolean indicating whether at least one element passes a test.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v ) {
    return ( real( v ) === imag( v ) );
}

const arr = new Complex128Array( 3 );

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

// Check whether at least one element passes a test:
const bool = arr.some( predicate );
// returns true
```

The `predicate` function is provided three arguments:

-   **value**: current array element.
-   **index**: current array element index.
-   **arr**: the array on which this method was called.

To set the function execution context, provide a `thisArg`.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function predicate( v, i ) {
    this.count += 1;
    return ( imag( v ) === real( v ) );
}

const arr = new Complex128Array( 3 );

const context = {
    'count': 0
};

// Set the first three elements:
arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, -3.0 ], 2 );

const bool = arr.some( predicate, context );
// returns true

const count = context.count;
// returns 2
```

<a name="method-sort"></a>

#### Complex128Array.prototype.sort( compareFcn )

Sorts an array in-place.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function compare( a, b ) {
    const re1 = real( a );
    const re2 = real( b );
    if ( re1 < re2 ) {
        return -1;
    }
    if ( re1 > re2 ) {
        return 1;
    }
    const im1 = imag( a );
    const im2 = imag( b );
    if ( im1 < im2 ) {
        return -1;
    }
    if ( im1 > im2 ) {
        return 1;
    }
    return 0;
}

const arr = new Complex128Array( 3 );

arr.set( [ 3.0, -3.0 ], 0 );
arr.set( [ 1.0, -1.0 ], 1 );
arr.set( [ 2.0, -2.0 ], 2 );

const out = arr.sort( compare );
// returns <Complex128Array>

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns -1.0

z = out.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns -2.0

z = out.get( 2 );
// returns <Complex128>

re = real( z );
// returns 3.0

im = imag( z );
// returns -3.0
```

The `compareFcn` determines the order of the elements. The function is called with the following arguments:

-   **a**: the first element for comparison.
-   **b**: the second element for comparison.

The function should return a number where:

-   a negative value indicates that `a` should come before `b`.
-   a positive value indicates that `a` should come after `b`.
-   zero or `NaN` indicates that `a` and `b` are considered equal.

In contrast to real numbers, one cannot define a default order relation which is compatible with multiplication. Accordingly, users **must** explicitly provide a `compareFcn` argument and are thus responsible for specifying a complex number ordering.

<a name="method-subarray"></a>

#### Complex128Array.prototype.subarray( \[begin\[, end]] )

Creates a new typed array view over the same underlying [`ArrayBuffer`][@stdlib/array/buffer] and with the same underlying data type as the host array.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const subarr = arr.subarray();
// returns <Complex128Array>

const len = subarr.length;
// returns 4

let z = subarr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns 2.0

z = subarr.get( len-1 );
// returns <Complex128>

re = real( z );
// returns 7.0

im = imag( z );
// returns 8.0
```

By default, the method creates a typed array view beginning with the first array element. To specify an alternative array index at which to begin, provide a `begin` index (inclusive).

```javascript
const imag = require( '@stdlib/complex/float64/imag' );
const real = require( '@stdlib/complex/float64/real' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const subarr = arr.subarray( 1 );
// returns <Complex128Array>

const len = subarr.length;
// returns 3

const z = subarr.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 3.0

const im = imag( z );
// returns 4.0
```

By default, the method creates a typed array view which includes all array elements after `begin`. To limit the number of array elements after `begin`, provide an `end` index (exclusive).

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ] );

const subarr = arr.subarray( 1, -1 );
// returns <Complex128Array>

const len = subarr.length;
// returns 2

let z = subarr.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns 4.0

z = subarr.get( len-1 );
// returns <Complex128>

re = real( z );
// returns 5.0

im = imag( z );
// returns 6.0
```

<a name="method-to-locale-string"></a>

#### Complex128Array.prototype.toLocaleString( \[locales\[, options]] )

Serializes an array as a locale-specific string.

```javascript
const arr = new Complex128Array( 2 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );

const str = arr.toLocaleString();
// returns '1 + 1i,2 + 2i'
```

The method supports the following arguments:

-   **locales**: a string with a BCP 47 language tag or an array of such strings.
-   **options**: configuration properties.

<a name="method-to-reversed"></a>

#### Complex128Array.prototype.toReversed()

Returns a new typed array containing the elements in reversed order.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const out = arr.toReversed();
// returns <Complex128Array>

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 3.0

let im = imag( z );
// returns 3.0

z = out.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns 2.0

z = out.get( 2 );
// returns <Complex128>

re = real( z );
// returns 1.0

im = imag( z );
// returns 1.0
```

<a name="method-to-sorted"></a>

#### Complex128Array.prototype.toSorted( compareFcn )

Returns a new typed array containing the elements in sorted order.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );

function compare( a, b ) {
    const re1 = real( a );
    const re2 = real( b );
    if ( re1 < re2 ) {
        return -1;
    }
    if ( re1 > re2 ) {
        return 1;
    }
    const im1 = imag( a );
    const im2 = imag( b );
    if ( im1 < im2 ) {
        return -1;
    }
    if ( im1 > im2 ) {
        return 1;
    }
    return 0;
}

const arr = new Complex128Array( 3 );

arr.set( [ 3.0, -3.0 ], 0 );
arr.set( [ 1.0, -1.0 ], 1 );
arr.set( [ 2.0, -2.0 ], 2 );

const out = arr.toSorted( compare );
// returns <Complex128Array>

let z = out.get( 0 );
// returns <Complex128>

let re = real( z );
// returns 1.0

let im = imag( z );
// returns -1.0

z = out.get( 1 );
// returns <Complex128>

re = real( z );
// returns 2.0

im = imag( z );
// returns -2.0

z = out.get( 2 );
// returns <Complex128>

re = real( z );
// returns 3.0

im = imag( z );
// returns -3.0
```

The `compareFcn` determines the order of the elements. The function is called with the following arguments:

-   **a**: the first element for comparison.
-   **b**: the second element for comparison.

The function should return a number where:

-   a negative value indicates that `a` should come before `b`.
-   a positive value indicates that `a` should come after `b`.
-   zero or `NaN` indicates that `a` and `b` are considered equal.

In contrast to real numbers, one cannot define a default order relation which is compatible with multiplication. Accordingly, users **must** explicitly provide a `compareFcn` argument and are thus responsible for specifying a complex number ordering.

<a name="method-to-string"></a>

#### Complex128Array.prototype.toString()

Serializes an array as a string.

```javascript
const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 2 );

const str = arr.toString();
// returns '1 + 1i,2 - 2i,3 + 3i'
```

<a name="method-values"></a>

#### Complex128Array.prototype.values()

Returns an iterator for iterating over each value in a typed array.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );
const arr = new Complex128Array( 2 );

arr.set( [ 1.0, -1.0 ], 0 );
arr.set( [ 2.0, -2.0 ], 1 );

const iter = arr.values();

let v = iter.next().value;
// returns <Complex128>

let re = real( v );
// returns 1.0

let im = imag( v );
// returns -1.0

v = iter.next().value;
// returns <Complex128>

re = real( v );
// returns 2.0

im = imag( v );
// returns -2.0

const bool = iter.next().done;
// returns true
```

The returned [iterator][mdn-iterator-protocol] protocol-compliant object has the following properties:

-   **next**: function which returns an [iterator][mdn-iterator-protocol] protocol-compliant object containing the next iterated value (if one exists) assigned to a `value` property and a `done` property having a `boolean` value indicating whether the [iterator][mdn-iterator-protocol] is finished.
-   **return**: function which closes an [iterator][mdn-iterator-protocol] and returns a single (optional) argument in an [iterator][mdn-iterator-protocol] protocol-compliant object.

<a name="method-with"></a>

#### Complex128Array.prototype.with( index, value )

Returns a new typed array with the element at a provided index replaced with a provided value.

```javascript
const real = require( '@stdlib/complex/float64/real' );
const imag = require( '@stdlib/complex/float64/imag' );
const Complex128 = require( '@stdlib/complex/float64/ctor' );

const arr = new Complex128Array( 3 );

arr.set( [ 1.0, 1.0 ], 0 );
arr.set( [ 2.0, 2.0 ], 1 );
arr.set( [ 3.0, 3.0 ], 1 );

const out = arr.with( 0, new Complex128( 4.0, 4.0 ) );
// returns <Complex128Array>

const z = out.get( 0 );
// returns <Complex128>

const re = real( z );
// returns 4.0

const im = imag( z );
// returns 4.0
```

</section>

<!-- /.usage -->

<!-- Package usage notes. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->

<section class="notes">

* * *

## Notes

-   While a `Complex128Array` _strives_ to maintain (but does not **guarantee**) consistency with [typed arrays][@stdlib/array/typed], significant deviations from ECMAScript-defined [typed array][@stdlib/array/typed] behavior are as follows:

    -   The constructor does **not** require the `new` operator.
    -   The constructor and associated methods support a broader variety of input argument types in order to better accommodate complex number input.
    -   Accessing array elements using bracket syntax (e.g., `Z[i]`) is **not** supported. Instead, one **must** use the `.get()` method which returns a value compatible with complex number output.
    -   The `set` method has extended behavior in order to support complex numbers.

</section>

<!-- /.notes -->

<!-- Package usage examples. -->

<section class="examples">

* * *

## Examples

<!-- eslint no-undef: "error" -->

```javascript
const Complex128 = require( '@stdlib/complex/float64/ctor' );
const Float64Array = require( '@stdlib/array/float64' );
const logEach = require( '@stdlib/console/log-each' );
const Complex128Array = require( '@stdlib/array/complex128' );

// Create a complex array by specifying a length:
let out = new Complex128Array( 3 );
logEach( '%s', out );

// Create a complex array from an array of complex numbers:
let arr = [
    new Complex128( 1.0, -1.0 ),
    new Complex128( -3.14, 3.14 ),
    new Complex128( 0.5, 0.5 )
];
out = new Complex128Array( arr );
logEach( '%s', out );

// Create a complex array from an interleaved typed array:
arr = new Float64Array( [ 1.0, -1.0, -3.14, 3.14, 0.5, 0.5 ] );
out = new Complex128Array( arr );
logEach( '%s', out );

// Create a complex array from an array buffer:
arr = new Float64Array( [ 1.0, -1.0, -3.14, 3.14, 0.5, 0.5 ] );
out = new Complex128Array( arr.buffer );
logEach( '%s', out );

// Create a complex array from an array buffer view:
arr = new Float64Array( [ 1.0, -1.0, -3.14, 3.14, 0.5, 0.5 ] );
out = new Complex128Array( arr.buffer, 16, 2 );
logEach( '%s', out );
```

</section>

<!-- /.examples -->

<!-- Section to include cited references. If references are included, add a horizontal rule *before* the section. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->

<section class="references">

</section>

<!-- /.references -->

<!-- Section for related `stdlib` packages. Do not manually edit this section, as it is automatically populated. -->

<section class="related">

* * *

## See Also

-   <span class="package-name">[`@stdlib/array/complex64`][@stdlib/array/complex64]</span><span class="delimiter">: </span><span class="description">Complex64Array.</span>
-   <span class="package-name">[`@stdlib/complex/cmplx`][@stdlib/complex/cmplx]</span><span class="delimiter">: </span><span class="description">create a complex number.</span>
-   <span class="package-name">[`@stdlib/complex/float64/ctor`][@stdlib/complex/float64/ctor]</span><span class="delimiter">: </span><span class="description">128-bit complex number.</span>

</section>

<!-- /.related -->

<!-- Section for all links. Make sure to keep an empty line after the `section` element and another before the `/section` close. -->

<section class="links">

[mdn-iterator-protocol]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol

[@stdlib/array/typed]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/array/typed

[@stdlib/array/buffer]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/array/buffer

[@stdlib/complex/float64/ctor]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/complex/float64/ctor

<!-- <related-links> -->

[@stdlib/array/complex64]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/array/complex64

[@stdlib/complex/cmplx]: https://github.com/stdlib-js/stdlib/tree/develop/lib/node_modules/%40stdlib/complex/cmplx

<!-- </related-links> -->

</section>

<!-- /.links -->
